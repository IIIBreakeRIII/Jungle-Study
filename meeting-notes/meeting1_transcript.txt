 아까 얘기했던 것처럼 파트를 3페이지씩 해서 각자 이해한대로 읽죠? 좋습니다 가위바위보 하실까요? 순서는? 할 수 없지 안 내면 진 거 가위바위보 당신 먼저 안 내면 진 거 가위바위보 와... 뭘 택? 2.1부터? 2.1은 32페이지? 맞죠? 제가 중요하다고 생각하는 부분만 읽고 넘어갈게요 2.1.1이요? 2.1이요? 32페이지요? 진짜 해 주실래요? 잠깐만 2.... 아니 아니 그게 아니라 어디까지 할지 볼게요 한번 어디서 꺼낼까 여기 너무 멀어요? 37페이지?
 뭔가 끊기는 느낌인데? 스트링 이어서 그 다음에 아 스트링 잠깐 해야지 오케이 한번 더 나 하세요! 하다가 힘들면은 뽑을테니까 하고 뭐 질문 있으시면 하세요 대답할 수 있으면 할게요 32장부터 보면 우리가 정수 처리를 어떻게 할 거냐를 배울 건데 크게 두 가지가 있죠 비부호형과 이해부수 이해부수 비부호형이 언사인드고 이해부수가 사인드 그래서 여기서 뭐 역사가 어쩌고저쩌고 하고 넘어갈게요 아 그리고 여기 하나만 오늘 4를 해서 알겠지만 부동소수점 뒤에 가면 범위가 크다 보니까 근사값을 계산하는 부분이 나온단 말이야 그래서 부동소수점은 범위가 넓지만 근사값으로 코디해야 된다는 특징이 있고 정수는 그거에 비해서는 비교적 작은 범위이기 때문에 더더욱 정밀하게 해야 된다 그래서 우리가 2.1에서 열심히 계산을 합니다
 이 점을 정보에 저장한 메모리에서 주소 지정이 가능한 최소 단위 8비트 단위의 블록인 바이트 를 사용한다고 합니다 그래서 여기서는 그냥 1바이트가 8비트다 2바이트 16비트 이렇겠죠 그리고 궁금해서 찾아봤는데 3바이트 뭐 이런 것도 있긴 있는데 CPU는 보통 1, 2, 4, 8 단위로 데이터 처리를 한대요 3바이트는 메모리 접근 시 정렬을 하기가 복잡해서 쓰지 않는다고 합니다 그리고 넘어가셔서 16진수 표시에서 16진수는 말 그대로 그거죠 숫자를 00,00 뭐 어쩌고 저쩌고 적기 힘드니까 10부터 15까지 알파벳 대문자를 이용해서 a부터 f까지 이용해서 손쉽게 표현하는 방식인데 1바이트를 8비트로 이루어진다고 앞에서 얘기를 했고 그래서 간단히 밑에 보시면 맨 위에 핵스라고 적혀있는
 16 진수 핵사 맞나요? 핵사 내시면 핵수 가운데께 10 진수 마지막께 2 진수 이거 표현하는 거는 아실 것 같아서 넘어갈게요 응 응 열심히 표현하시고 16 진수 바꾸는 것도 열심히 하시고 그 다음에 2.1.2는 모든 컴퓨터는 워드 크기라는 걸 갖는데요 이거 뒤에서도 많이 나오는데 정확히 명명하면 CPU가 한 번에 처리하는 데이터 단위 자체를 워드라고 한대요 그리고 이 워드라는 게 왜 중요하냐 우리가 쓰는 시스템의 가상 주소 공간의 최대 크기를 워드를 통해서 나타낸대요 그래서 뭐 예를 들어서 32 비트 워드 크기를 갖는 크기를 4GB로 표시하고 64 비트는 16 엑사바이트 어쩌고 저쩌고로 표현한대요 근데 우리가
 크기 32bit와 64bit 컴퓨터가 있는데 당연히 32bit에서 돌아가는 건 64bit에서도 돌아가겠죠? 다만 64bit에서 돌아가는 건 32bit에서 안 돌아갈 수도 있겠죠? 그래서 그런 크기가 있고 왼쪽에 위에 보시면 뭐 무자형부터 숏트, 인트 다 나오고 여기 인트32 언덕바티는 다들 아시겠지만 고정형 정수라고 합니다 이걸 쓰는 이유는 프로그래머들이 데이터의 표현을 안전하게 통제하려고 걸어놓은 자료형이라고 이해를 했습니다 그리고 그 옆에 아 잠시만요 음 방금 얘기한 것처럼 자료형이 엄청 많잖아요 그래서 프로그래머들이 꼭 지켜야 되는 게 내가 작성하는 프로그램이 이 컴퓨터에서도 돌아갈 수 있고
 이 컴파일러에서도 동작할 수 있도록 하는 게 중요하고 그걸 우리는 호환성이라고 표현한다고 합니다 그리고 보통 최저한계 값 자체를 시연어가 지정을 하고 있는데 상위한계 값은 정의하고 있지 않대요 그리고 프로그램을 우리는 어쨌든 0101이라는 여러 바이트로 표시를 하는데 크게 보아야 하는 게 두 가지가 있는데 객체의 주소는 어떻게 이루어져야 되고 메모리의 바이트들 공열동리를 대체 어떻게 정렬해야 하는지가 중요한 숙제라고 합니다 그래서 첫 번째 객체의 주소가 무엇이 되어야 하는지에 대해서 좀 말을 바꾸면 자료형 별로 크기에 맞는 정렬 된 주소를 우리는 사용해야 된다 그리고 메모리의 바이트들을 어떻게 정렬해야 하는지를
 책에서는 두 가지 소개하고 있는데 하나는 little andyian 이라고 하고 나머지 하나는 big andyian 이라고 합니다 이름에서 볼 수 있는 것처럼 little andyian은 가장 덜 중요한 바이트 라고 해서 lsb 라고 하고 얘를 앞쪽에 저장하는 방식을 얘기하고 big andyian은 가장 중요한 바이트 msb 라고 해서 뒤에 나오는 부호 나타내는 바이트들을 앞에 저장하는 방식이라고 하는데요 이거는 저번에 코어 갔다가 들은 건데 little andyian 방식을 훨씬 더 많이 쓰고 원래는 big andyian 방식으로 쓰다가 little andyian 이라는 걸 발견해서 그게 붙어진 거래요 그리고 사실 컴퓨터에서 little 이냐 big andyian 이냐는 크게 중요하지 않답니다. 웬만하면 근데 중요한 경우가 세 가지가 나오는데 책에서 소개하고 있는 첫 번째 경우가 우리가 그 0101 자체를 어떤 네트워크를 통해서 다른 컴퓨터로
 전송될 때인데 만약에 나는 리트렌디언으로 표시했는데 저쪽 컴퓨터는 빅앤디언이면 정보가 아예 바뀔 수가 있겠죠 그래서 그때 중요하고 두 번째는 정수 데이터를 나타내는 바이트들을 살펴볼 때 말 그대로 정수는 바이트들마다 크기가 바뀌니까 순서가 중요할 거고 마지막을 저는 좀 깊게 봤던 건데 그때 예시를 올려드렸던 파일인데 그 프로그램이 정상적인 타입 체계를 회피하도록 작성되었을 때 제가 이걸 왜 찾아봤느냐면 시연화 할 때 형 변화하면 오륜하는 경우가 엄청 많잖아요 근데 그게 이거랑 관련된 거라고 해서 찾아봤는데 시연화에서는 그 정상적인 타입 체계, 차형으로 한 거를 인트로 바꾸거나 인트를 숏트로 해석하는 그 방법을 두 가지가 있어요. 캐스트랑 유니언이라는 방식이 있는데 어...
 캐스트는 포인터 타입 자체를 바꿔서 다른 타입처럼 읽어버리는 거고 유니온은 하나의 메모리를 여러 타입으로 해석한 합법적인 방식이래요 그런데 캐스트나 유니온이 방식이잖아요 타입, 체계를 회피하는 방식 근데 이거를 사실은 웬만하면 제한을 해야 된대요 문제가 아까처럼 있을 수 있으니까 그런데 이걸 그럼에도 불구하고 쓰는 이유는 하드웨어를 제어하거나 어떤 오해 기법을 사용하는 속도를 최적화하거나 저 수준의 데이터 포맷 제어를 할 때는 그 뭐 이러면서 인트형으로 받았을 때 나는 끝비트만 필요하면 숏트로 줄여서 하는 게 더 이득인데 그러면 타입형 변환으로 얻을 수 있는 이득이 너무 크기 때문에 위험을 감수하고 쓴다고 합니다 캐스트나 유니온 방식을 통해서 그 중에 저희 그림 2.4에 나온 게 캐스팅 방식
 보시면 여기 type-def에서 bytepointer라는 변수가 비보호형 문자를 읽기 위한 포인터를 지정을 했잖아요 근데 12번째 줄을 보면 bytepointer에 들어가는 게 int형이죠 그래서 x 자체는 원래 int이기 때문에 x의 주소는 intpointer로 읽혀야 돼요 근데 우리가 보호 없는 문자를 읽는 bytepointer로 읽었기 때문에 짤리겠죠? 읽어야 되는 4byte에 비해 차는 1byte이기 때문에 3byte가 잘려나갈 거예요 그럼에도 불구하고 이를 사용하는 이유는 아까 얘기했던 여러 가지 이득이 너무 커서 사용한다고 합니다 그래서 여기서 넘어가고 여기 2.6 부분에 뭐 리눅스 어쩌고 저쩌고
 이 타이틀을 보면 3930으로 시작하는 게 니트랜디아 그리고 유일하게 저 썬이라는 머신만 00으로 시작할 때 얘가 비겐디아 근데 뒤에 가서 계산을 해 보면 알겠지만 어? 아니, 나 뒤에 가서 얘기할게요 그러고... 네, 그 정도면 될 것 같아요 다음 분 누구시죠? 겹치는 내용도 다시 하셔도 돼요 어떻게... 내가 먼저... 형님은 모르는 부분 뒤에서 따로 하셨으니까... 어... 그럼 어디까지 하세요? 어... 46쪽이요 머신 좀 타이핑하면서 들어오도 돼요? 네 46도? 네, 46
 아니 그러니까 어디까지 그냥 이 점을 끝낼게요 제가 네 아아 왜냐면 제가 정표 표시가 너무 어려워서 네 자 그러면 일단 스트링의 표시 다른 거 볼 거 없고 이것만 보면 됩니다 아스키 코드 제일 중요한 거죠 아스키 코드만 알고 있으면 되고 아니 코드의 표현 여기도 사실 딱히 중요한 건 없어서 이게 좀 나는 다 저는 거의 다 노션으로 해놔서 요정한 대로 보는 게 좀 알 것 같은데 컴퓨터 타입에 따라서 호환성이 없는 인스트럭션과 인코딩을 사용을 한다고 되어 있는데 결국에 이게 기계 코드에서 지금 모두가 실행한 결과가 다 다르다는 게 컴퓨터 타입에 따라서 이 호환성이 없다라는 거겠죠 그렇기 때문에 어떠한 저거를 써도 당연히 호환성이 서로 될 수 있는 코드를 만들 수 있는
 그리고 이제 불대수가 나오는데 사실 저는 불대수는 이것만 알고 있어도 된다고 합니다 연상 Not End War, Exclusive War 이렇게를 알고 있습니다 연상을 보면 다들 아시죠? 제가 따로 얘기는 안 하죠 그리고 이 불대수를 빅팩터에도 적용할 수 있다는데 그런데 이거다 여기 있네 52쪽 빅팩터 불대수는 빅팩터를 적용 가능하다 쉽게 생각해보면 UNT POP에 적용을 해봤을 때 A라는 값을 0101001 즉 0356을 나타내는 값과 0246을 나타내는 값을 합지법 교정
 그리고 예술법이 각각 모두 가능하다 라는게 이 불대수에서의 적용, 비트팩터의 적용이고 그리고 CSI 비트수준 연산을 넘어가면 비트 대관의 불률 연산이 지원된다 그리고 비트 마스크 연산을 구현할 때 사용하는데 사실 제가 2.1 연수 문제가 아마 제가 여기 왜 뱁플레 쳐놓을까 지금 이거 풀다보니 머리가 아파서 뱁플레 쳐놓은 것 같은데 연수 문제 2.1이야 일단 뭐 여기까지 얘기를 하면 여기서 얘기하는 비트 마스크랑 뭐 하는 것은 일종의 비트팩터이고 어떤 중에 일부 선택된 비트수준을 표시한다 이 정도를 좀 낼 수 있을 것 같고 잠깐만요, 이거를 왜 제가 왜 이렇게 했을까요? 내가 모르는 걸 여기에 다 배열을 해놨는데 같이 한번 볼까요? 적성하는 코드는 5대의 크기야 W가 8열보다 크거나 같은 모든 것들에 대해서
 저게 된다 20이 있고 20이 나 뭘 풀었는데 이거 뭘 구하라는 거야 아 그냥 찾으라는 거 같은데 전 안 찾습니다 다른 비트들이 0인 X의 가장 덜 중요한 바이트는 회 끝에 있는 2일이고 2일이고 가장 덜 중요한 바이트를 제외한 나머지 고수를 취한 값은 반대를 구고 X의 가장 덜 중요한 바이트를 제외한 다른 비트들이 0인 오케이 1, 0, 0 내가 이걸 왜 뺄 줄은 없을까? 많이 힘들어 넘어가자 넘어가고 연속 문제는 보니까 딱히 편안한 문제들이 너무 뒤에 답이 다 있어서 맞아요 하다가 저걸 하면 되고 C에서의 논리 연산 이 부분 조금 중요한데 C에서는 논리 연산이 5월에
 논리연산자를 사용합니다. 논리연산은 0이 아닌 인자들에 대해서는 모두 투류를 하고, 0일 때는 false가 나옵니다. 그리고 수식의 결과가 첫 번째 인자를 계산해서 결정될 수 있다면, 두 번째 인자는 계산하지 않는다. 그러니까 이 챕터에 대해서 자격심이 되지 않을까 생각합니다. 그리고 CSOE 쉬프트 연산은 논리연산은 X, 좌시프트 K라는 랫트로 K피트만큼 이동을 한다. 우측 쉬프트 연산은 논리우측 쉬프트 연산과 산수로측 쉬프트 연산이 두 개가 있는데, 논리우측 같은 경우는 좌측 끝을 K로 채운다. K계를 영어로 채운다. 자측 끝을 K로 채운다. 이 부분을 자세히 보면 쉬프트 연산을 하는 방법이다.
 이 보호형 점수 연산에서 유용하게 적용을 한다라고 해서 맞네요 자측 시프트, 우측 시프트에 따라서 1111을 채울 건지 0000을 채울 건지 그리고 우측 시프트가 여기서 이제 중요한 시프트로 채울 건지 덜 중요한 시프트로 채울 건지에 대해서 얘기를 하고 있는 부분입니다 그리고 사실 이 점이랑 끊기지 않아요 시프트 연산은 뭐 플러스카나 최근에 했어서 특히 여기도 뒤쪽은 별로 중요한 게 없었어 혹시 뭔가 좀 짚고 넘어갔으면 하는 게 있을까요? 짚고 넘어갔으면 하기 보다 그 마지막에 57쪽에 마지막 렌다? 네, 시표 주는 보호형 숫자의 경우에 어떤 타입의 우측 시프트가 사용되어야 하는지 명확히 정의하고 있지 않다 저는 이 문장이 궁금해서 찾아봤거든요
 지정해버리면 될텐데 왜 안하는가 했더니 그거를 이제 컴퓨터가 지정을 해버리면 컴파일러의 선택권을 제한하기 때문에 하드웨어에 맞춰서 최적화 할 수 있는 자열을 뺏기게 된대요 그래서 지정을 하지 않는다고 합니다 그것만은... 없어? 같은데 사실 연선이 다른데 혹시 뭐 따로 더 알아보고 싶었던 내용이 있으실지 콧물에 LD pardon
 혹시 아까 했던 분의 비트 베터 마스크 있잖아요 이 비트 베터 마스크가 말 그대로 걔를 씌워서 뭔가 정보를 변화하는 거잖아요 근데 얘가 뭐지? 무슨 기술인 거예요? 근데 저는 사실 이런 걸 처음 보긴 했어요 비트 베터 마스크? 왜냐하면 뒤에도 계속 나오는데 사실 나는 이렇게 계산해 본 적이 없어서 비트 베터 영상에서는 실제로 많은 용량으로서 비트 베터를 사용해서 직섭을 인코뉴만 해보면서 도입이다 8장에서 어떤 프로그램을 주면 좋을지 이 시그널에 대해서 배우게 된다 8장에 주면 됩니다 어디에 있었어? 분재품이 위에 있어요 마지막에 있는 거 아세요? 그건 있어요 비트 베터인지 모르겠는데 마스크 자체가 씌워서 정보를 제가 원하는 것만 볼 수 있어요
 그런 곳에서 많이 쓰인다고 해서 디스플레이에 쓸 수도 있을 것 같고 아니면 단순히 데이터를 봤는데 쓸 수도 있을 것 같고 그렇습니다 네 8장에서 볼 수 있으면 좋겠네요 8장까지 살아있었으면 좋겠는데 2.2이에요 준비 되셨죠? 네 네 그리고 이것만 나중에 드릴게요 제가 찾다가 그냥 플로시랑 더블 때문에 궁금해가지고 별명을 먹고 플로과 더블이 어떤 시키 다르냐 플로스는 싱글 프리시전인데 더블 프리시전이다라고 이런 내용인데 실례하겠습니다 감사합니다 주문시켜서 금방 오기 싫다면 읽으시면... 그것도 읽기 싫으면 어떡하지? 그러면 좀 하세요 오늘 시험 중에 대가리로 거짓말을 하시던데 누구? 뭐 얘기하는 거야?
 아 나? 네 뭐하는거야 하 조용히 너무 웃겨져있단 말이야 아 정말요? 아 진짜 살아있지 아 키에 꼬는거 용량은 있어요? 아 용량은 나 오 대박쓰 네 뭐 2.2 시작하시죠 네 2.2 인쇄 표시부터 시작할게요 네 어 끝이다가 넘겨주세요 뭐 여기 2.2 이 단어부터는 이제 양수를 표시할 수 있는 단어들과 응수, 영수, 양수 모두를 표시할 수 있는 이제 방법에 대해서 설명을 하는 단어의 세터가 될 것 같은데 일단 언사인드라는 타입이 있어요 언사인드는 이제 부어오는 정조를 의미하고요 0 이상인 간만 표현할 때 이제 타입 앞에 박혀야 됩니다 그리고 다음으로 이제 투스컴플리먼트라는 이 보수 라는 게 사용이 되는데요 이 부분은 음수와 양수 그리고 영 모든 모두
 이의 고수를 해석한다. 이의 고수에서 유가 보오는 정수를 대응한다. 그리고 이다시 9화 32mm 프로그램의 C정수형 전주의 범위와 이 주 4bit에서의 C정수형의 범위가 나오는데 중요한 게, 음수의 범위가 양의 범위보다 1이 더 많아요.
 그리고 제가 아까 좀 봤던 건데 여기서 아까 말씀해주신 롱이랑 그 이제 더블 부분, 더블 부분, 아 잠깐만 롱 부분만이요? 네 롱 부분이 지금 32비트에서는 21억 정도 되고, 그리고 아래 24비트에서는 맞아요 거의 2배? 2배는 아니구나? 어마어마하게 늘어납니다 그리고 24비트 프로그램은 8비트를 사용을 하고요 그래서 아래 보시면 중요한 특징은 범위들이 매칭하는 것이 아니라 음제번위가 양이 범위보다 1 더 넓다라는 것을 알아주시면 될 것 같습니다 그래서 이제 음수가 컴퓨터에서 어떻게 표시되는지 이제 설견대에 얘기할 수 있을 것 같은데요 그렇게 넘어가고 2.272, 2.2 비보영 인코딩입니다 비보영은 이제 언사인들을 이미 하죠 이제 8, 제가 아까
 바이너리 B2U가 B2 unsigned여서 이제 아래에 있는 저 B2U4 그리고 이제 뭐 이 개수를 0001을 보시면 이제 이거를 이제 unsigned? unsigned로 이제 이 개수를 unsigned로 이제 평가하는 것을 보여드릴 수 있는데요 이제 저희가 이 개수를 계산할 때 이제 10제수로 바꿀 때 자릿수별로 2의 n제곱 이게 3제곱 2제곱 1제곱 0제곱 해서 값을 다 더한 것이 이제 바이너리와 바이너리, 이제 unsigned죠? unsigned인가 되는 걸 확인해볼 수 있을 것 같고요 그리고 네, 이.2.2.2는 그렇게 생각 그렇게만 보시면 될 것 같습니다 이제 2.2.3부터 이게 보고서 인코딩이 나오는데요 이제 부형 숫자를 컴퓨터에서 표시하면 가장 일반적인 방법입니다 가장 기계어라는 형태로 많이 알고 있는데요 어디 가장 중요하...
 다양한 복태를 음주 자리 값을 갖는 것을 해석하는 형태로 이해부순이 인코딩이 장인 됩니다. 어... 마찬가지로 지금 여기에서는 Binary to Unsigned에서 Binary to Tools Compliment 이제... 어... Binary가 이제 이진수에서... 아니지? 네, 이진수에서 Binary가 이진수야? 네 Binary가 이진수 아, 이진수에서 이해부순이지 헷갈려요 네, 이제 이진수에서 이해부순을 갖고는 건데 마찬가지입니다 그것도 마찬가지인데 이제 좀 특별한 것은 이제 이진수에서 음수가 음수를 보면 맨 앞자리 이해부순을 음수로 본다는 것을 생각해서 각 별로 이엔스끼리 더해서 더한 값이 이해부순인 거라고 확인할 수 있을 것 같고요 음... 네, 여기서는 증명하는 부분이라서 설명 안 했는데 제가 여기서 조금 놓친 부분은 Umax라는 부분이랑 좀 그런 부분이 좀 헷갈리긴 하더라고요 그래서 이 부분으로만 Umax 팀이...
 네, 그쪽은 제가 헷갈려서 따로 메모는 하지 않았던 것 같습니다. 너무 오래 걸릴 것 같아서 2.2.4로 하죠? 네 제가 여기서 사인드와 언사인드의 아니, 좀 더 사인드 좀 더 사로 넘어가면 비부용과 부용의 형변화 부분이 나오는데 사인드와 언사인드가 서로 변화하는 건데 이 부분이 캐스팅을 허용합니다. 그래서 비트는 그대로 두고 비트를 해석하는 방식으로 바꿔서 숫자를 바꿔 있는 것인데요. 예제 69페이지 오른쪽 상단을 보면 숏의 윈트피는 마이너스 1-3-4로 하죠. 그걸 언사인드 숏을
 쇼츠로 UVA해서 언사인드 쇼츠 이렇게 감싸서 한 변환을 했을 때 플레이트를 하면 이게 마이너스 12345으로 이제 이제서 16비트로 표현되면 1150 1150 1150 이거를 나 한 번에 쓰긴 좀 그래서 근데 이거를 빨리 빨리 해야 하면 좋으니까 근데 이거를 16비트로 바꾸면 이제 그렇게 0X 0X 앞에 붙죠 그리고 CLF C7이 됩니다 근데 이거를 언사인드로 형 변환을 하는데요 언사인드를 형 변환하면 비트는 그걸로 하니까 똑같이 OSCF 07인데 이건 양수로 해석됩니다 그래서 또 이걸 다시 형 변환 이제서 바꿀 때 1150 1150 1150 1150 1150 인성191이라는 인성191이라는 형태로 변환이 되는 것만 확인될 수 있어요
 빨리 하는게 좋죠 잘했어요 아래쪽 보면은 어쌍드 이면은 어마어마한 사이구석 불지로 그 부분을 보면은 이거를 인트로 바꿔한다는 거는 이 비트를 이제 사인드 인트로 이제 해석을 한다는 거거든요 그래서 이제 이거를 또 16제에서 바꾸면 이의 곳에서 이 앞두 마이너스 1을 뜻합니다 그렇기 때문에 이게 어마어마한 1일이 되거든요 이렇게 그래서 앞자리가 1이면 그냥 마이너스 1이 됩니다 이의 곳을 해석하면 그냥 마이너스 1이 됩니다 네, 올스 에펠트 페펠트 페펠트 페페도 그냥 이의 곳을 바꿨을 때 마이너스 1이 된다 라는 것을 우리 2.5 좀 온대요? 어, 2.5 정도 넘어가기 전에 그.. 뭐야, 2.2.4
 2.24? 일단 2.24를 가기 전에 2.24에 여자로드 2.18 다를 다 푸셨나요? 2.24에 여자로드 2.18 아니요 저 이것만 체크해봤어요 저도 안 푸셨습니다 요거를 제가 사실 오늘 같이 풀어보면 좋을 것 같아요 왜냐면 이게 여기 rsp rax 이거 나중에 할 것 같아서 맞아요 rsp rax요? 여기 여기 여기 그리고 이게 어섬블리어 명령어던데 어섬블리어 명령어라서 이게 무슨 의미인지 정도만 알고 넘어가도 좋을 것 같아서 맞아요 저 체크해놨어요 네 알겠습니다 그럼 같이 한번 해보시죠 네 2.24 하면 이 정도 설명하면 될 것 같네요 대충 혹시 umax랑 tmax 정리 안 하고 넘어가도 돼요 두 분? 해주세요 해주시면 좋을 것 같아요 그 되게 간단해요 u... u요? 있는 사람... 봐봐요 진짜 간단해
 이게.. 잠깐 잠깐 오케이 오케이 말이 어렵지? 왜 이렇게 썼지? 65페이지 어디? 목장지 어.. 내가 증명하다 머리탱이 다 뽑힐 뻔했어 2.6% 선인 거고 2.2% 아 나 숫자 그만 얘기해 2.2.2였구나 2.2.2 아 정신이 날 것 같아 일단.. 어.. 뭐지? 그 U-MAX를 설명하기 위해서 이거.. 저 볼게요 어.. 예를 들어서 이런 비트가 있다고 칩시다 얘를 해석할 수 있는 방법은 얘기하셨던 것처럼 UNSIGNED랑 SIGNED가 있죠? 절대 UNSIGNED와 SIGNED는 비트를 바꾸는 연산이 아니에요 읽는 방법이지 근데 UNSIGNED는.. 난 아닌가? 뭐 이상한데 어 G 아니면 그쵸
 Unseen! Unseen! 노래해보자는 게 있어 미친거 아니야? 봐봐요 Unseen들은 부호가 없죠 Sides는 부호가 없죠 아야 저거 봐봐 B 부호가 없죠 Sides는 부호가 없죠 얘는 노래 불러야 하는 거 나 배 아파 미친놈아 울고 싶어 울고 싶다 너무 안 되겠을 것 같은데 다시 놀아보자 쉽게 생각해봐요 얘는 표현할 수 있는 숫자가
 여기 0, 1 두 개, 여기 0, 1 두 개, 여기 0, 1 두 개, 여기 0, 1 두 개 우리 고등학교 때 배우는 경우에 있으면 2 곱하기, 2 곱하기, 2 곱하기이니까 이게 자수야 16개밖에 우리 표현을 못해요 근데 얘는 부호가 없고 즉 양수만 쓸 거고 얘는 음수도 표현을 해야 돼 그러면 0을 기준으로 대칭적으로 표현한다고 했을 때 얘는 표현할 수 있는 수의 범위가 더 적겠죠 왜냐면 같은 3이라는 숫자에 얘는 마상도 표현을 해야 되니까 그래서 얘는 0부터 표현을 해야 되니까 16개를 쓸거면 0, 1, 2, 3, 4, 0, 0, 0, 0 해서 15까지 표현할 수 있죠 그래서 얘의 범위는 0부터 2의 빈트 숫 빼기 1까지 표현할 수 있어요 4 비트면 15까지 할 수 있죠 그럼 사인드는 얼마만큼 할 수 있냐면 똑같이 0부터 2의 n승인데 그냥 n승이 아니고 m-1승이에요 음... 아
 n-1승, 마이너스 1이에요 똑같은데 여기 n-1로 바꾸죠 왜냐하면 나는 2에 n승을 반으로 나눠서 양쪽에 써야 되니까 2에 n승을 이루어놓은 수학적으로 n-1이 되죠 그럼 반대로 당연히 마이너스 2에 n-1도 표현을 하겠죠 근데 아까 설명 중에 그 뭐지? 그 말이 있어요 음수와 양수는 대칭적으로 존재하지 않는다고 우리 자료영에 있어서 그게 왜 그러냐면 0이 양수에 포함돼서 그래요 마이너스 8부터 마이너스 1까지는 8개죠? 0부터 7도 8개죠 그래서 여기가 대칭적으로 존재하지 않아요 그래서 그 표에서도 보면 보험포 넘어갔으면 했던 게 2.9랑 2.10은 비트에 따른 시정수형 자료영 일반 범이고 2.11 그림을 보면 보장된 범이라고 나와 있어요 60페이지? 60페이지 왼쪽 2개는 비트에 따른 시정수형을 표현할 수 있어요
 그리고 2.12는 보장된 덤이라는 게 무슨 말이야? 얘 되게 보기 짜증나잖아요. 비대칭이. 그래서 마이너스 7부터 7 대칭을 이렇게 썼을 때 모든 토론을 해서 이건 무조건 보장해야 된다. 마이너스 8은 보기 좀 그러니까 빼는 거고 이거는 무조건 보장해야 된다는 게 오른쪽 표예요. 그러면 여기서부터는 다 끝났어요. 이거 언사인드죠? 얘는 사인드고 투스컴플리먼트? 그래서 이 거를 언사인드에서 나타내는 가장 큰 숫자여서 이 맥스인 거야. 아, 언사인드 맥스 해가지고 이것도 써요? 그러면 T맥스는 1점? 얘가 T링이고 그게 답니다. 그래서 65페이지에 보면 U맥스는
 이 tmax 플러스인데 쉽게 생각하면 돼요 우리 아까 16개 표현한다고 했는데 얘는 부호를 양쪽 다 표현하니까 반으로 나눴어야 됐죠 그래서 umax를 나타내기 위해서는 tmax 예를 들면 우리가 아까 숫자 7을 예시로 들었죠 7을 2배 하면 12, 14 거의 1도 하면 15가 나오죠 쉽게 쉽게 생각하면 돼요 2개 이쪽에 썼던 거 이제 나는 다 언사인데 쓸 거니까 2배가 되고 플러스 2는 원래 마이너스 1이었으니까 그래서 밑에 표보면 umax 8바이트 아 그런 건가요? 8비트에서는 최대가 0, 0, 0, 0, 0, 0, 0 그래서 f,f가 제일 큰 숫자인 거고 뭐 비트가 늘어나면 f 기수가 많아진다고 생각하면 돼요 t,e는 반대로 깊어질 거고
 2.2.4는 아까 했고 그... 아 그리고 이거 1sign으로 읽는 방법 아까 얘기한 것처럼 2에 0, 2에 1 승하면 되고 sign으로 읽고 싶으면 얘가 1이면 얘를 막 8로 읽으면 돼요 맞나요? 1, 2, 3, 8? 맞아 최상위 비트를 마이너스를 주면 돼요 그리고 또 궁금해서 찾았거든요 왜 얘만 마이너스인지 왜냐면 얘가 비트 하나 늘어나면 얘는 다시 플러스로 바뀌고 얘는 얘가 마이너스 신용으로 바뀌잖아요 그래야 어떤 특정 비트를 봤을 때 겹치지 않아요 다른 숫자로 그러니까 이게 되게 똑똑하게 만들어진 건데 뭐 예를 들어서 누군가가 보고 제가 지금 정확히 예상을 기억이 안 나는데 얘를 1이라는 숫자를 멋대로 가정<|ro|>
 이걸 순수하게 표현할 수 있는 숫자는 이게 어떻게 운존하지 않을까 라고 생각을 했는데 다 따져 오는 이유는 되게 아, 이게 되게 이런다 무조건 고유한 숫자래 그래서 최상위 밑에 왜 마이너스를 붙이냐고 하면 음수와 양수를 겹치지 않게 모두 고유하게 나타내기 위해서라고 얘기를 한다고 합니다 그리고 뭐 그 2.6 같은 식 보면 2.6 식이 좀 중요하거든요? 다른 거는 모르겠는데 이 식이 자꾸 뒤에서 또 나오더라고요 2.2.6이요? 아니요, 그 이거 71p의 식 맞아요 맞아요 2.1도 맞죠 내가 이거 여기에 제명하다가 겟보처럼 보면 이것도 이 왼쪽 밑에부터 보면 T민이랑 T맥스는 우리 이제 알죠? 네 근데 T2 이유는 그러면 E의 보수를 부호 없는 점수형으로 바꿀 건데 어... 예를 들어서 뭐 인영 인영 얘는 T로
 그러면 마 8이랑 2인가요? 마 6인가요? 그쵸? 맞죠? 근데 얘를 언사인드로 바꿀거에요 그러면 여기다가 뭐만 나오냐면 2에 4비트만 들어가는거에요 2에서? 왜요? 이거 생각나는거에요? 아 그... 이거 이거 약간 솔직히 이게 이해가 한번 되면 그때부터는 시간을 외우면 되잖아요 굳이 매 순간 증명할 필요 없고 근데 한번 정도의 증명은 저는 필요한 생각도거든요 봐봐요 이 위에는 어떤 이집법을 제가 언사인드로 읽을거에요 그러면 비트 벡터를 나타냈을때 x3이라는 숫자에는 8이 알단되겠죠? x2라는 애는 4 알단될거고 x1은 2 x0은 0 1이죠? 아 1이요? 이번에는 비트 7을 읽을게요 똑같은
 T를 읽으면 아까 최상위 B2-라고 했으니까 이렇게 되죠? 뒤에는 똑같을 거예요 그러면 위에서 아래를 뺄게요 뺄면 이거 다 지워지고 누구만 남아요? 얘 맞죠? 그럼 B2U에서 B2T를 뺀 시그널 T를 적게 적게 뺀 2 곱하기 XS에 8이 있는데 그렇죠 그럼 얘는 V에 4승 곱하기 X3승이죠 그래서 T2U라는 식이 이렇게 나옵니다 2에 W 밑이랑 X3에다가 원래 숫자 더 하는 거 사실 이거는 그림이 제일 좋아요 2.17라고 해요 그림이 진짜 양어진 게 0을 기준으로 음수는 그러니까 0을 기준으로 원래 아까처럼 마이너스 8에서부터 7을 표현하는 사인드가 있고 0부터 15를 나타낼 수 있고
 저는 어사인도 있으면 쉽게 생각했을 때 얘도 0이랑 7이 있죠 얘도 0이랑 7이 있죠 얘는 있는 거 그대로 갖다 쓰면 되는 거 얘가 문제인 거잖아요 얘를 위로 올려치기 하면 돼요 원래 음수였던 애를 뒤에 8, 9, 10, 11, 12, 13, 14, 15가 쓰는 걸로 끌고 오면 되는 거예요 그 그림이 그림이에요 그래서 양수인 거는 그대로 직진하는 거고 음수인 게 위로 올라가는 거 최대한 안 바꿔야 좋은 거니까 그리고 반대는 똑같겠죠? 그리고 U2T U2T는 더 쉬운 게 우리 방금 했던 최단기 비트는 무조건 마이너스 붙이기로 했죠? 그래서 그 2.8씩이 마이너스 U, W 마이너스 1, E에 W 승해 U 가
 그 다음은 부호 비트에요 그래서 음수면 걔를 1처리 해주면 되는거고 양수면 0이어서 그냥 유는 유다 오빠 질문이 어디에요? 뭐? 질문? 아까 모르는.. 아 됐다고 그거는 2.2.4였고 문제 풀리는거는 2.1.3였고 뒤에 마무리 싹 하고 보죠 아 그럴까? 그렇게만 중요한거같아 어디부터 말할지 2.2.5였는데 저에요? 네 네 2.2.5 네 1? 이 C에서 부호형과 비교해야 돼요? 2.2.5였어
 그러면은 언싸인 해 노래를 부르고 노래를 애시하고 와 절대 안 까먹겠다 응 또 또 진짜 모르겠어 이제 기본 개념을 이제 아래 쪽에 있는 예제 말고도 잠깐만 잠시만 네 이거 얘가 이거 다 적어야겠다 없는데 이게 뭐 아 예제? 응 마카 얍스 저렇게 보니까 나 아이패드 사고 싶었네 아이패드 뭐 있으면 저것도 있으면 안 쓰고 없으면 사고 싶고 있으면 뭘 봐요? 응
 잠시만 너 뭘 섞은거냐 아니 이게 이렇게 잠깐만 찾으셨어요? 여기가 비료인데 제가 프레임테프에서만 프레임테프 부분을 쓴 것 같은데 73번 디테일이 있는 프레임테프를 비보영수로 비보영수로 쓰시는 것 처럼 그런거 사용하는건데 제가 그 부분밖에 안쓴다 그러면 이제 인트 인트 X가 마이너스 1이라고 해봅시다 네 1사인은 1사인은 말할게
 그리고 3개월째 이거는 2인의 31승 이거를 프린트 프린트 F의 함수를 통해서 프린트에 출력을 해볼텐데 이제 X 중요한 프린트는 그리고 이제 프린트 F 있을때 %S, %D, %U를 쓰잖아요 %U로 쓰고 %D 이렇게 쌍꺼풀 닫고 변수를 넣잖아요 그죠? 변수를 넣어서 출력을 하면 되죠 그러면 여기에 있는 %U는 이제 이 U가 사인들을 읽는거에요 그리고 여기 있는 D는 사인
 그래서 그냥 여기서 출력을 한다 그러면 이제 마이너스 1을 마이너스 1이 이제 마이너스 1이 16층으로 떠나면 이제 여기 있어 여기 해놨어 아 있어요? 해놨어 여기 해놨어 여기 해놨어 아 감사합니다 형 이제 거기서 에펩펩펩 펌펌 펌펌 뭐였어 에펩펩펩펌 에펩펩펩펌 에펩펩펩펌 에펩펩펩펩 이거는 이거를 다시 풀어쓰면 풀어 쓰게? 언사인으로 해석을 한다면 아이씨 사이보 아 사이보 불경피샤스? 그냥 해야 되는데 올라가야 돼 그래서 이 X를 언사인으로 해석을 한다면
 사인드에서 출력을 시키면 마이너스 1이 나오는 게 아니라 이건 마이너스 1 출력되겠지만 이거는 이게 출력됩니다. 네. 그냥 이런 식으로. 이렇게 D는 그냥 사인드 형식으로 그대로 넣는데 이게 UNSIGNED를 통해서 마이너스 1을 BBO 형으로 사인과 며칠을 못 보고 네. 네. 저는 프리테이프는 2.2.5<|id|>.0으로 제작을 했고요. 그리고 어? 그냥 이게 제가 어제 C2000 진짜 캡처해가지고 붙여놓았거든요. 이거? C 타입이지 그거? 네? 그거 C 타입이지? 네. 아, 저기 저기 저기. 어? 잠시만요. 아, 저 이거 음주 넣을 수 있어요. 오, 좋아? 참 나. 생생하게 많이 좋아졌어.
 에플 TV 잇기 officially 이렇게 뽑으면 돼 패드도? 괜찮잖아 미라링 하면 될 거 같기도 하고 미라링 거기? 뭔가 떴어 김씨는? 제가 이거 백뚜껑에다 꽂을게요 아니 됐다 됐는데
 아...몰라 디스플레이 들어가서 됐다 내가 보면은 이거를 돌려야겠다 어? 어? 어? 어? 어? 어? 어? 어? 어? 어? 어? 어? 어? 어? 어? 어? 어? 알겠어 알겠어 그 표현식을 보시면 근데 위에 평가 타입이 on side 울지 말고 해봐 중요한 건 side가 on side로 돌아온다 그 다음 percent d 이거 보시면 아시겠지만 percent u는 on side로 출력되고 percent u는 on side 맞죠? percent d는 on side로 출력이 됩니다 제가 말했던 대로 마이너스 32에 2에 못서죠
 이게 16제에서 바꾼 거거든요? F8개 그게 언사이드로 바뀐 걸로 사인구석을 입추어 그래서 X는 마이클 1위지만 언사이드로 봤을 때는 사인구석을 입추어 사실... 그리고... 진짜 중요한 건 이거 표현식이긴 한데 저 이거는 진짜 못하겠어요 너네요? 너네요 내가 뭐라 설명해야 할지 모르겠어 내가 설명하면 적어놨어야 했는데 내가 그냥... 팩트어보는 거 같은데? 이거를 설명을 해야 하나? 확대의 조각이 있잖아 이 뒤에 육아부품에 적어 언사인 되고 맞아요 저게 언사인 됐을 때 저게 더 크다 작은다 라는 표현식을 보면 결과가 2호 풀스 그걸로 나오는 거 같은데 그럼 네 맞네 이렇게 나오니까 비부형이니까 이렇게 나오고
 아아 아아 그니까 같은 비트를 모를 윙냐에 따라서 부를 값이 달라진다는 거죠? 네 그럴 수 있죠 아니 값이 바뀌지 않아요 아까는 x가 마이너스 1이긴 했지만 언사이드 했을 때는 사이구사 그룹질을 받쳐주시고 아 그거 외우겠는데 외우겠는데 사이구사 그룹 이런거 나중에 링크 같은거 있으면 하나만 이렇게 달아주세요 미묘하게 좀 좀 어디서 캡쳐 바닥에 걸거 아니였어? 직접 한거야? 지선생님한테 아 GPT? 지선생님한테 좋지 2.1.6 수위 비트 표지로 여기는 진짜 0을 확장 0을 확장시켜 볼거에요 여기는 방법이 두가지가 있는데 이제 제로 익스텍션이라고 0을 확장인데
 여기는, 아 여기도 여기 확장되어 있네? 네, 0의 확장인데 이거는 비보영 선수, Onsigned를 좀 더 큰 타입으로 확장할 때 사용합니다 좀 더, 타입을 좀 더 확장을 하게 됐을 때 이 빈 자리를 0으로 채우거든요 그래서 0의 확장이라는 표현을 쓰는데 근데 이게 의미가 없어요 양수 확장을 하기 때문에 그래서 여기 제가 예를 들면 8G Onsigned과 OXF, F0이죠 F0을 10G 들어온 240, 20G 들어온 1116500에 16G 확장을 해보거든요 그럼 이제 8G 뜨는 1116500인데 거기서 16G를 확장을 했으니까 이 8G 앞이 있는 이 이 얘네는 얘네가 이렇게 뒤로 옵니다 네, 이렇게 뒤로 오고 그 앞은 다 0으로 채운다 네, 그거 원리에요 이거는 어려운 거 없어요 그럼 다음은?
 근데 얘네는 조금 더 중요해 이제 부호형 종무 종무 아까는 unsigned였지만, 이제 signed 부호형 번호수를 더 큰 타입으로 확장할 때 이의 모습을 표현하자 생각합니다 그리고 제가 이거는 MSB 최상위 부호 빚대로 확장하는 거 그래서 빈 자리를 시험하는데 저는 아직 이 MSB가 얼마 안 됐어요 이따가 설명해 주시면 좋을 것 같고 그리고 이제 음소를 왜냐하면 unsigned는 양손 만이 있었으니까 이번엔 signed를 통해서 음소를 통해서 표현하기 때문에 꼭 필요합니다 왜냐면 아까 위에 것처럼 적용한다면 이 음소가 가장 앞다리 수 있는데 표현이 안되겠죠 그래서 마찬가지로 똑같은 예제 OXF형 십진수는 마이너스 16형이고 이제수는 111166형입니다 또 마찬가지로 8m랑 아까는 위에 거랑 똑같죠 그리고 똑같은데 마찬가지로 또 이 8m이 뒤로 옵니다 지금 아까 영의 확장을 통해서 아까 unsigned를 통해서 이렇게 이렇게 이렇게 이렇게 이렇게 이렇게 이렇게 이렇게 이렇게 이렇게 이렇게
 사이드는 0으로 치웠다면 사이드는 앞을 제 앞자리 입술을 따서 1111을 다 부사한다 그래서 확장의 값은 여전히 마이너스 16으로 유지가 됩니다 이게 2.2.6인데요 뒷부분에 대한 시는 진짜 눈가에 빠질 것 같아서 못 읽었어요 시? 어디요? 이게 2.2.6인데요 이게 70일 77일 70일 77일 저 진짜 이 시가 알아듣지 못합니다 오메가 뭔지도 몰라요 시계브랜드가 뭐예요? 이번 부분으로 넘어갈까요? 뭐? 오메가 시계브랜드 오메가 진짜 못먹고 놀라게 이 부분 한 번 넘어갈까요? 좋습니다 같이 해보죠 그 일단 이거 얘기하는 거죠? 이 10? 이것도 간단합니다 최상위 뒷트는 일단 딱 그거예요 최상위가 어디야? 제일 높은 곳 제일 높은 곳에 있는 거 읽으시면 됩니다 마이너스 8이요
 Bambi 거 뭐예요? YS8이요? 아니요 눈 없어요? 눈썹 눈썹이야? 아니요! 뭐냐고 이거! 도빈이 형님! 이거 뭐예요? 눈썹은 YS! YS8! 내가 봤다 보니 뭔지 알 것 같지? 아니 이거 뭐예요? A지 그렇죠 1위 최장위 밑에 그러면 이건 최장위 밑에 뭐예요? 0이죠 두 개밖에 없겠죠? 8, 0은 아니에요? 네 그러면 얘가 최장위 밑인데 여기서 수혜 확장할 때 0은 열심히 확장해봤자 의미는 없다고 했잖아요? 네 자 이게 뭐예요? 사인 들어가면? 사인 들어가면? 응 값이 뭐죠? 계산할까요? 각자 마음속에서 계산할까요? 하나 둘 셋 하면 이긴다 잠깐만 잠깐만 4 아닌가요? 뭐라고요? 잠깐만 잠깐만 아 5시구나 6일
 핸드로 읽으라고 했어요 안돼 안돼 여기 봐 사이드는 0주잖아 마인스 3 아니지 사이드는 0주까지 포함이 아니라 그럼 여기 2에 2에 2에 2에 2에 2에 2 그럼 마인스 4 마인스 4인데 뒤에 1 더 있고 마인스 4? 그쵸? 근데 얘를 얘 몇 피트에요? 4피트 근데 4피트를 확장하면 더 확장해도 되는데 기차형이 다 돼서 4피트를 확장하면 아까 부호형은 MSB를 따라서 확장하면 근데 MSB가 뭐라고요? MSB가요? 최상위 비트가 뭐라고요? 최상위 비트가 MSB야? 네 같은 말이에요 MSB가 가장 중요한 비트 그러면 1이죠 1 앞에 붙이면 돼요 근데 4비트니까 하나만 붙이면 되겠죠? 이게 우리 그때 경사에 해줬던 건데
 아잉 마사가 뿔사고 바뀌죠 네 그럼 이 둘을 정하면 싹둑 즉 이해부수의 확장도 비트 모양이 변할 뿐이지 값은 변하지 않아요 그거를 지금 쉽으로 어렵게 적어놓은 건데 이게 어렵지 않은 이유가 뭐냐 봐봐요 비트티는 바이너리를 티로 읽는 거 우리 방금 한 거 이게 비트티죠 근데 비트티를 어디 이거는 내가 W를 3으로 한 거야 이거 패러디우 3으로 쓸게요 이게 지금 우리가 하는 짓이죠 그럼 얘는 비트가 3개니까 이거에 할당된 숫자를 X2라고 하고 X2 곱하기 2에 세고 X1 2에 1 X0 2에 0죠 이렇게 되니까 이렇게 되니까 N은 마이너스 이게 지금 비트티 여기
 빅2t의 오메가는 x 오메가 마이너스 1부터 시작할 때, 우리 봐봐요. 3이고, 하나 줄어든 2죠. 그게 2식인데, 얘를 하나로 늘릴 거야. 뭐로? t4로. 하나 늘릴 거야. 그게 2식이죠? 네. 2식 했을 때 우리 이렇게 됐어요. 이 x이 있는 뒤로 가고, 뭐가 생겼지? x3이 생겼죠? 그렇죠. 봐봐요. 왼쪽 그림에, x3이 2, 3이 뭐고. 어, x 오메가 마이너스 1이 k times라고 돼 있는 거예요. 지금 우리는 하나 늘렸으니까 k랑 1이어서, 앞에 하나가 늘어난 거고, k가 2였.. 즉 내가 3비트를 4비트가 아니고 5비트로 바꿨으면, 앞에 있는 이게 총 2개 늘어나. 이거까지가 원래 있었다. 근데 여기서 뭐가 오메가예요? 요요요요요요, 이거 w. w가 오메가야? 어, w를 오메가라고 해 봐. 나 진짜 몰라서 봤어. 모를 수도 있어. 맞아, 나도 원래 몰랐어. 근데 봐봐. 여기랑, 여기는 x 오메가 마이너스 1부터 마이너스 2지. 그럼 얘는 x 오메가 마이너스 1부터 똑같이 마이너스 2지. 그럼 여기, 오른, 여기서부터 여기까지는..
 그럼 이 앞에 게 생겼는데 이 앞에 게 우리 거 이거 함틱스 늘어나는 거면 x4로 하나 늘었고 하나 더 늘리면 x4로 늘고 그게 k만 늘은 게 뷰티의 표현이랑 같다 근데 가운데 드모 있죠? 왜 드모 있어요? 우리 두 개산했을 때 같잖아요 그게 다예요 아 이해되셨다 그래서 이해됐어요 그리고 이 뒤에 이거 이거 시그마 있는 시근 그것만 보면 돼요 이렇게 표현되어 있는 거 x 오메가 마는 1부터 e 뒤집어 놓은 거요? 그쵸 좋네요 이 숫자 3 왼쪽으로 뒤집어 놓은 거 이거 이거 보는 방법이 쉬운 게 뭐냐면요 이거 합이거든요 그러니까 이거 쉽게 못 껴 x i e i 아니 예시를 하나 틀어주고 약간 다시 석강서 된 느낌이네 x i e i요? 아니 x i e i로 하지 말아요
 거기에다가 X 플러스 1이나 계산하기 쉬운 식으로 하나 넣고 저거가 어떻게 되어있는지 알게 되죠? 내가 여기를 3으로 숫자로 바꿀게 응 그러면 i도 똑같이 3으로 바꿀게 아니야, 이렇게 내 그러니까 이게 식이야 그럼 봐봐 얘는 더하기를 나타내는 기호거든 그러면 0부터 3이면 숫자가 몇 개야? 세 개지 네 개지 네 개지 네 개지 네 개지 그러면 네 번을 더해야 한다는 소리야? 네 번을 더? 어 저거 봐봐 저거 숫자가 0부터 3면 0, 1, 2, 3 넌 네 번의 식을 해야 해 어 근데 식은 이걸로 고정이야 i가 0일 때부터 이렇게 i가 지금 어딨어? 여기 있지? 여기 있지 있는 그대로 둘게 이게 i가 0일 때 그럼 i가 1일 때는 이렇게 돼 있지? 어디까지? 4가지 아 이게 딱 저거야? 20% 어 그래서 이거는 뭔데? 이 앞에 이 마이너스 보여? 마이너스 X 오메가 마이너스 2, 5, 4가? 응 이게 그거 우리 아까 P2T3에서 여기 살
 마파리 새로 생겼지 그 마파를 내탔던게 있는거지 이거 동그라미 쳐 놓고 MSB라고 써 있잖아 MSB? MSB! 최상위 비트 제 하이 비트 그래서 이것만 보면 돼 사용한 주요 성질은 EOm-U 이게 최상위 비트 늘려도 값이 같은 이유 오케이 최상위 비트 그리고 뭐 뒤에는 다시 하실 거죠? 그것만 짚어놓을게요 표현하다가 좀 멋있는 걸 하나 용어를 알아왔는데 문제 2점 이상을 제가 풀다가 좀 헷갈렸던게 있어서 뭘 찾아보나 알게 됐는데 또 당연히 다들 아실 수도 있는데 시험화에서 인트로 캐스팅한다는 것 자체가 기본 타입이 싸인
 저는 원사인드나 사인드가 안 적혀있으면 그게 문제인 줄 알았는데 기본이 사인드래요 그거랑 치현우의 정수승격규칙이라는게 있대요 정수승격규칙이요? 정수승격규칙이라는게 있는데 이게 뭐냐면 인트는 몇 타입이죠? 아 몇 타입인지 알아보네? 몇 바위죠? 4바위 2? 근데 정수승격규칙 이게 뭐냐면 가끔 여기 함수들 보면 인트 말고 차나 쇼트 이런거 있잖아 인트보다 크기가 작은 정수형 자료들이 인트 연산에 낀거에요 예를 들어서 X라는 애는 인트형이고
 Y라는 애는 Short면, 근데 나는 X도 아니고 Y를 했어 그러면 그 Y가 더 작았던 애가 저절로 인트로 변환이 된대요 시연어의 저는 알아서 변환을 하는데 이때 왜 그거를 시연어가 멋대로 변경을 하냐면 시연어가 쓰는 연산자들은 기본적으로 성능이랑 호환성 때문에 무조건 인트 이상의 크기를 필요로 안 돼요 Short 자체는 입력하는 순간부터 의미가 없는 거죠 어차피 인트로 바꿔서 연산할 거기 때문에 그래서 그걸 정수... 정수... 정식이라고 한대 Short로 선언을 해도 컴파일러가 알아서 인트로 계산을 한다면서요? 인트와의 연산을 끼려 Short를 더하기 Short면 Short인데 Short 플러스 인트면 인트로 바뀐대요 처음으로 하네 그러니까 저도 신기해서 찾아봤어요 잘 써! 잘 썬 것 같아요? 응!
 제목인데요 하하하하 하시죠 자 이제 X를 숏트 타입으로 번화할 때 잠깐만 잠깐만 잠깐 잠깐 정신을 표현할 때 더적을 비트수로 잘라내는 트롯케이션 연자는 각분쎄 일부 손실 오버플로우를 수렴할 수 있습니다 그래서 사인들과 안사인들에 동작이 다르네요 네 알겠습니다 인테리어 X 인테리어 X는 오마스터부터 191입니다 하지만 숏트를 X를 흉변화시킨다면 오마스터부터 191은 마이너스 12345이에요 그치만 숏트를 인테리어 X를 바꿔버리면 그것도 마이너스 12345이에요 하지만 이거를 이긴 수로 바꿔본다면 숏트 X는 0
 4백짜리 그 4개와 하지만, 이제 16Bit만 잘라서 또 쇼트나운드 한 번 더 해봐라 마찬가지로 이 뒤에 부분만 살아있어요 하이씨트 나무 이 모습 표현으로 마찬가지로 아까 말했듯이 마이너스는 마이너스는 45 또 32부트로 복장이 인트로 형변하는 표시가 확장이 되지만 이때는 도복장, 사인 익스테네이션이 되어서 앞자리가 0이 아닌 다시 1로 확장한게 됩니다 아까 이거죠? 여기 썼던거? 네 트렁케이츠입니다 W에서 K 밑으로 숫자를 줄이는 것입니다 그래서 앞쪽에 W- 오메가요? 오메가 많이 더 스케일 비트를 전환한다고 생각합니다
 한 40 몇 개? 좋습니다 이 뒤에 있는 이 B2T, B2U 이거는 사실 안 쳐다봤어요 안 쳐다봤어요 아니 근데 수학과학 증명을 내가 안 해야 하나? 그렇죠 아 그래 맞아 나는 수학과학 아니기 때문에 그렇죠? 저희는 개발자죠? 네 다음 조언 2.28인가? 네 잠깐 잠깐 나 이거 뭐 어쩌고 온 거니? 잠깐 잠깐 여기 뭐 있었나? 여기 없었을텐데 어? 어? 이거 이거 이거 그거 여기 중요한 거 하나 있어요 뭐요? 저거 뭐지? 사인드, 언사인드 아까 우리 캐스팅할 때 캐스팅 방식이 2개 있다고 나오는데 네 이거 앞쪽에 그 뭐라고 표현이 되어있냐면 아 그 명시적인 캐스팅이 있고 묵시적인 변수할 당했다고요 명시적인 변수할 당
 명시적인 캐스팅은 예를 들어서 명시적, 묵시적 캐스팅? 이게 TX가 뭐 언사인드 관련된 거라고 합시다 근데 얘를 UX가 언사인드에요 근데 나는 얘 인트형이 알고 싶은 거야 그 사인드나 그럼 여기다가 이렇게 가끔 시안을 해서 코딩할 게 없잖아요 이게 명시적인 캐스팅 그리고 묵시적인 캐스팅은 뭐냐면 애초에 선언 자체를 인트를 UX로 하고 언사인드를 TX로 해요 그러면 내가 때로 이렇게 해버리겠다 UX는 TX까지 내가 직접 선언을 한 거야? 어, 이거까지 한 거야 똑같이 얘는 UX를 인트로 변한 해라고 적어놓은 거고 얘는 UX를 아, 반대네요 그러면 아, 반대네요 그러니까 나는 똑같이 인트형이 궁금하다 근데 얘는 UX를 인트로 바꿔줘
 그게 TX야 라고 얘기하는거고 얘는 UX는 TX야. 근데 알고보니까 TX가 임시였던거고 이게 암흑적인거고 이게 명시적인 캐스팅 묵시정 아니야? 아, 그니까 묵시정이고 명시정 근데 문제는 이게 가끔 문제가 생긴데요 그거에 대해서 나온 내용이 마지막 파트인데 그 뒤쪽에, 아 이거 2.2.8 초반에 묵시적인 타입 변환을 하면 다소 직관적이지 않은 동작입니다. 얘에 비해서 직관적이지 않죠? 변수를 다 찾아 봐야하니까 그래서 이게 문제가 언제 생기냐면 뒤에 있는데 아, 이게 제가 정리를 해놨는데 잠시만요 내가 어제 TIL 정리를 했던거 같은데 그래, 이거 내가 코드랑 많이 쓰던거 같은데
 아 생각보다 이유는 간단하네 그 그냥 그거에요 그 우리 부호랑 비구호랑 같이 다르잖아요 그렇기 때문에 멋대로 이렇게 했다가 내가 원하는 연성 결과가 안나오는게 문제점인데 그럼에도 불구하고 얘도 쓰는데요 왜 쓰냐면 밑에 그 밑에 덩어리 덩어리요? 비구호형 값들은 어디게 되게 되나 숫자 값을 요게 이제 그건데 그러니까 이거 언사인드랑 사인드랑 이거야 만약에 변환을 하는게 내가 모르는 문제점이 생길 수 있어 그럼 가장 쉬운 해결법은 하나를 없애버리는 거죠? 하나만 있으면 되잖아 타입이 그래서 보통 시영어는 언사인드를 없애는 경우가 많대요 그래서 시영어는
 자바는 애초에 언사인들을 지원하지 않고가 아니고 C 이외에 다른 언어 시험하는 언사인들을 지원했으니까 저희가 여기까지 했겠죠? C 외에는 아예 지원자세를 안 한대요 왜냐면 헷갈릴 수 있으니까 그리고 유용성보다 문제점이 더 많다고 생각을 해서 자바 같은 경우는 사인드만 지원을 한대요 맞아요 근데 시험하는 예를 왜 남겨주냐 그게 이제 밑에 부분이에요 비부형 값들 언제 중요한게 쉽게 생각하면 양심값만 쓰겠다는 거잖아 양심값만 있을 때 좋은거는 주소 주소에는 음색값이 필요가 없잖아 그리고 나머지 여기 뭐 내가 나머지 찾아 봤는데 플래그라는 게 있더라고 혹시 다들 들어보셨나요? 그 무슨 비트 플래그라고 해서 비트 마스크 느낌인지
 총 3가지를 봤는데 플래그랑 주소, 그리고 세 번째는 수학 패키지 아~~ 플래그를 저는 몰라서 좀 더 찾아보려고 하긴 하거든요 그래서 뭐 이런 게 있어서 시험원 지원을 한다! 가 마지막 내용이었어요 조금 더 추가자면 아까 안시접 평범한 할 때 사인들에서 언사인들을 바꿀 때 아까 설명했었는데 x는 마이너스 1에서 언사인들 평범한 할 때 40 몇 억을 바꿔 이걸로 별때 매우 큰 양수로 바뀌기 때문에 그래서 컴파일러는 먼저 변경하고 지호자 바꿔버려서 그래서 사용할 때 조심해야 되고 그래서 제가 찾아왔어요 언제 어떤 사인들을 써야 할까 반복문을 제작해서 배열기에는 그냥 사인
 우리 일반 하이자 하는 것처럼 비트 주자, 마스터 플랫 그럴 때 언사인드도 많이 쓰고요 메모리 주소가 버퍼 크기 할 때도 언사인드도 사용을 하긴 하는데 조심을 할 필요가 있다 네, 이 부분만 생각하면 됐습니다 그래서 반복물 루터나 조건을 입혀서 이런 형전안이 일어났을 때 생각보다 이상한 결과가 초월이 될 수 있다 조건을 조건하네요 네, 그렇게 2자부터 끝났습니다 이제 문제를 풀어볼까요? 이게 나도 플랫으로 해서 기억은 안 나는데 아마 그럴 거예요 메모리 뭔가... 회사 메모리 덜 잡아받게 하려고 이거 쓸 때는 비트한테 쓰면서 같이 쓰는 걸 알고 있는데 오래돼서 기억이 안 나네 혹시 그러면 우리 이번 주 목요일까지 플랫 할래?
 알아보고 아 목요일까지? 응 이번주 목요일까지 이틀 뒤에 왜냐면 두 분 다 2.2까지만 볼 거 아니야? 난 뒤에는 이렇게는 해야지 뒤에는 이렇게는 해야지 어때 플래그 간단하게? 이렇게 하면 아 뭐야? 아 니꺼부터구나? 응 저 플래그 말고 어 저거 맞아 맞아요 이거 맞아? 아니 이 플래그는 그냥 그거야 그냥 변수인데? 응 그냥 변수야 시야가... 시야가 2매드라고 원사인 보고 이미지 읽자 144개 어 적은 거 같아 옵션을 주스 많이 주고 어 적어 적어 플래그를 다 블랙으로 사용합니다 차의 관화 설정 오이씨 시
 그러니까 이게 인트, 이런 인트랑 언사인드 인트 천수축받은 정수령 변수의 국지를 플래그로 사용한다 권한을 진단하는 건데, 이제 어떤 면에서 권한을 진단하는지 모르겠네 너 왜 갑자기 설명하고 있는 거야? 어때요? 이거? 목요일까지? 네? 좋죠? 목요일까지요? 네일오일요? 네 그리고 아까 문제를 풀어봐야 된다 맞아요 혹시 문제를 풀기 전에 2.3 설명해도 돼요? 네 하세요 읽으실 때 도움이 될 겸 저는 복수 발견 근데 간단간단하게, 왜냐면 굳이 그렇게 깊게 보고 싶은 내용들이 아니어서 빠르게 빠르게 2.3 설명 2.3은 그냥 그거예요, 나는 정수로 더하기도 하고 싶고 빼기도 하고 싶고 곱셈도 하고 싶고 나노셈도 하고 싶은데 비트가 넘친다 나 이거 어떡하지? 가 2.3이에요 그래서 이 그림이 안 왔는데 이거 그림 때문에 쫄았었는데
 2.2일 보면 이렇게 되 있잖아요 근데 여기서 좀 좋았던 말이야 왜? 그 x와 y가 둘 다 선형 아, 이거 됐다 함수는 2.3.1 왼쪽 아래에 과로로 함수는 양쪽 측에 대해 선형 관계를 갖는다 봐봐요 이렇게 x로 증가하고 있는데 y도 증가해야 되는 이렇게 증가하겠죠 그게 이 모양이래요 그리고 자, 쉽게 15 더하기 4는 뭐예요? 18이요 얘는 4비트 안에서 나타낼 수 있나요? 반대죠 그때 생기는 게 이 단어의 문제점인데 그게 첫 번째 2.11 이것도 그냥 뭐예요? x 더하기 y의 u메가는 뭐 이렇게 되 있잖아요 그냥 x와 y만 더한다는 소리예요 언사인부도 입장해서 그럼 x 더하기 y는 x 더하기 y예요 그대로 언제? 범위를 안 나가서 예를 들어 x 더하기 4 같은 거
 여전히 4m 안에서 나타낼 수 있죠? 근데 만약에 넘쳤어! 그러면 넘치는 만큼 자르겠다는 건데 예를 들어 18이잖아요? 18에서 몇 잘라낼까요? 16 잘라낼게요 그럼 뭐가 되죠? 이게 절살입니다 언사인드의 절삽 질서 네? 질서 그래서 여기 너무 당연한 건데 16이라는.. 아, 이거요 15라는 숫자를 안 넘으면 자를 필요가 없죠? 근데 넘으면 빼야겠죠? 그리고 넘는 경우를 우리는 오버플로우 한다고 한대요 근데 문제는 C프로그램은 오버플로우는 에러를 표시하지 않아요 그래서 개발자들이 항상 여기서 문제점을 찾기를 힘들어하는데 이것도 공부해서 찾아봤죠? 왜 에러를 표시 안 한다는 건 실행이 안 된다는 거에요 근데 문제는 컴파일도 되고 실현도 된대요 다만 결과맞이 이상하게 나오는 거여서 보통 눈치를 못 챈다간
 그러면 어떻게 나타날 거냐면 예를 들어서 x라는 숫자랑 y라는 숫자를 저어 했는데 z라는 숫자가 있는데 얘는 얘보다도 작아요. 말이 돼요? 아니죠? 큰 거랑 큰 거랑 더 큰 게 나와야 되는데 줄어들었다는 건 뭔가? 잘렸다는 거죠. 그래서 이런 경우에 아 오버플로우가 발생했구나.를 나타내면 되는 거고 그게 자요. 그리고 이거는 그냥 나중에 보시면 되고 전 간단히 설명을 하기로 했으니까 이해보수에 더쌤도 똑같아요. 마이너스 8 더하기 마이너스 8을 했으면 마이너스 16이고 아까 했던 것처럼 사인드는 2에 오메가 마이너스 1부터 마이너스 2에 오메가 마이너스 1만 변화한다 그랬죠? 예를 들어서 4비트면 마이너스 8부터 7까지만. 근데 마이너스 8 더하기 마이너스 8은 마이너스 16을 위해서 표현할 수 없죠. 그러니까 또 생기는 문제인데
 어떻게 하는 거냐면 어... 얘는 그림을 보면 돼요 이 2.23 그림 여기도 그림을 참 잘 그려놓은 게 봐봐요 케이스의 2, 3가 쉬우니까 2, 3 먼저 볼게요 케이스의 2는 어... x 플러스 y라는 값이 애초에 저 범위 안에서도 그러니까 마이너스 2개를 더했더니 마이너스 3이 와요 얘는 범위 안에 있죠 그럼 얘는 그냥 그대로 표현하면 되는 거고 2를 더했는데 3이야 얘도 여자들이 잘못하는 수 표현할 수 있으면 그대로 표현하는 거고 근데 문제는 넘쳤으면 케이스 4가 파스티브 오버플로우라고 돼있는 게 7보다 큰 숫자로 더해졌으면 걔는 거기서 2의 오메가를 빼서 음수 쪽으로 웹힌을 해요 그러니까 넘치면 2의 오메가를 빼주면 되고 너무 부족하면 2의 오메가를 더해주는 거고 그게 다예요 근데 여기 이렇게 어렵게 표현돼있는데 그 말이 그 말이에요 그냥 넘치면
 2의 오메가처럼 빼버리고 너무 모자란 2의 오메가를 더해줘요. 그래서 얘도 오버플로우를 감지하는 방법은 똑같아요. 우리가 더한 숫자가 더한 숫자가 나와야 되는 대소비교가 있는데 그것보다 이상하게 나오는 오버플로우가 발생했구나. 그게 다고 곱셈은 더 쉽습니다. 그냥 3곱판 이상은 9인데 얘 표현 못하죠? 그러면 예를 들어서 3은 1, 9, 8지? 뭐죠? 001? 001. 001이지. 아, 001이죠. 죄송합니다. 001이죠? 이 둘 곱할 때 9가 나오려면? 8, 9, 8. 11001. 이거 맞아. 1248. 아, 뭐라는 거야? 저 10001이죠. 어, 그렇지. 그럴 필요가 있어. 근데 보면 너는 4가 있다. 아, 몰라. 하여튼 대충 했는데 막 이렇게 됐어. 아니면 이렇게 됐어. 더한 곱판까지. 그러면 이 길을 다 치워요. 뭐 또 해? 안 해줘. 그냥 이것만 남길 거예요. 뻥뻥해.
 어. 그냥 앞에 뭐가 있고 이런 거 다 필요 없고 그냥 뒤에 거 막 남겨. 근데 걱정되잖아. 앞에 거를 멀대로 저렇게 절삭을 했는데 괜찮을까? 근데 이거는 두 분이서 해보세요. 그 똑같아요. 얘를 이렇게 해서 잘라내든 그냥 계산을 하든 값이 변하지 않아요. 그러니까 맘놓고 잘라도 된다가 이 단어는 주된 내용이에요. 그러니까 그냥 곱하기 열심히 하기. 여기가 제일 어려운 거든요. 그 94, 95 케이지? 보면 다 식가도 장난치지 않았어요. 여기 더 그렇고 여기도 그렇고 여기도 그렇고. 근데 한 줄로 제가 뭐라고 정하느냐면 즉 계산은 언사인드로 하는데 해석을 사인드로 할 거니 언사인드로 할 거냐. 무슨 말이냐면 어떤 비트를 봤는데 101이랑 011을 곱하래요. 근데 얘는 언사인드야. 우리는 사인드 곱하기 사인드를 하고 싶어. 근데 다 필요 없고 언사인드로 읽어요. 그럼 얘는? 1. 아니지. 3. 말았어. 5. 언사인드로. 언사인드니까. 5. 1, 2, 5.
 뭐지? 얘는? 어 1, 2, 3 그러면 5x3은? 15 15죠? 얘를 비트로 나타내요 그 다음에 사인들을 읽고 싶으면 사인들을 읽고 언사인들을 읽고 싶으면 언사인들을 읽어요 그게 사인과 언사인들 곱셈이에요 네 네 책 좀 보시면 되고 거까지만 할래요 그러세요 뒤에도 똑같아요 그거랑 곱셈은 아 그것만 중요해요 컴퓨터는 정수형 곱셈과 정수형 나노쌤은 굉장히 못 한대요 메모리도 많이 먹고 그래서 절대 직접 계산하는 게 아니고 시프트랑 더샘팰샘을 이용해서 곱셈과 나노쌤을 한다 그게 끝 네 그래서 저는 2.3을 본 입장에서 시기 너무 어렵다 하면 넘기시는 게 나을 것 같아요 굳이 그렇게 좋은 식들이 아닌 것 같아서 알겠습니다 울지 마세요 힘들어? 울까? 우리 잘했어 이거 책만 6시간은 못봤는데 우리 아직 하나 남았어
 2.4? 문자 풀어졌어 아 맞다 어디 페이지였죠? 빨간색깔 여기있다 68 이거 맨 위에꺼 하나만 봅시다 뭘 의미하는지를 좀 알면 풀릴 것 같은데 이거 미미를 모르겠어서 서브 뭐해 애들 서브는 그게 다 어선블리어 명령으로 해서 대현이 형한테 찾았어 서브가 빼기고 아 모브? 시프트? 모브가 시프트 현실일 것 같고 애드가 더 하길 것 같은데 느낌이 그냥 그러면 얘를 비트로 먼저 쓸까요? 비트로 써야 되는거 아니야? 아 모브 애드 이게 오프월드야? R&B R&B 아 모브가 복사니?
 복사구나 MOV가 왜 그게 복사죠? 마음에 안드네요 서브 애들은 고학이고 서브는 빼는게 맞네 그럼 모브는 복사요 저거 야나 좀 보여 보여줘 자꾸 오빠는 왜 이렇게 빨리 내꺼로 뽑아 그래서 뭐지 뭐지 하고 있었어 이건 뭐야? 뭐? 나인데? 와 똑같아 똑같아 똑같아 이거 태그 쓰는 사람이 있구나 편해 나도 이거 있는데? 이거 무슨 파일이지? 이거? 입학시험 그래서 나도 입학시험 CSAPP 아 아 세플로 치시면 나올거야 아 2.18
 68페이지니까 90페이지 더해서 78페이지 더 2.1로 더 가야 돼? 2.1로 맞는데? 그림 2.1로 아니었어? 몰라 잠깐만 남도일 같아 목소리 그래 피규어 2.1로잖아 그 위에 여기 In Chapter 3에서 우리는 볼 것이다 Listing generated disassembler에 의해 만들어진 저걸 볼 거다 너 또 저거 예약해서 그렇게 바로 넣으면 어떡해 어 넌 성장이라는 키워드에 있어서 넌 수단과 광고를 가지 말라고 뭐야? 언제 깎아
 이 이미지는 엑셈블리 코드에서 32비트 2볼수까지 실제 속을 해석하는 문제입니다 이게 엑셈블리 명령어래 X8064에서 사용되는 엑셈블리 명령어래 이게 명령어라는건가? 0XEJ 근데 이거 16개에서 아니야? 이게 이게 명령어야 RSP RSP가 명령어 저게 주소값 같은거 아니야? X8064라는 아키텍츠죠 그래 이거 2200-730 부호 비트가 0이야 그쵸 어 잠깐 부호 비트가 0이야? 쥐 왜 이렇게 똥같은 소리야 736 혹시 이거 그냥 뒤에 답 한번 볼까요? 9. 뭐였죠? 8 1.18 해답 2.18 해답 736이네 뭐야?
 이상해 맞네 5층에 나타난 신속 수급 값들을 당연히 신속 수급 변환을 합게 넘어갑시다 근데 왜 이렇게 어렵게 써놨어? 그니까 잠깐만 저 RST가 그러면 해당이 되는 거야? 안 되는 거겠지? 응? 안 되는 거지? 레스는 뭐예요? 어 어디? 여기 퍼센트 레스 RAS 밑에 거 두 번째 줄에 RST 뭐 레스는 안 해줘서 찾아보면 돼 지하 레스 레지스터라고 하는 레지스터네요 EXTREME ROOTS 아키텍치아에서 해 한다는 번역 레지스터라고 언제가 뭐였지? Instruction 이별 명의 우츠가 명의하고 이별 우츠 T.M.I.N 그러면 난 이 점 더 버려버리면 안 되겠지 그러면 다음 주에 해야 될 거 준비를 한번 해봅시다 굿 목요일까지 플래그 오늘이 오늘 꼭
 오늘이 몇일? 22일 노션에 뭐 적는거죠? 일단은 슬랙 슬랙을 적고 정리해서 제가 노션을 다시 올려놓을게요 숙제칸이라고 하나 만들어볼게요 숙제 일단은 목교일 23일 24일까지 뭘 좀 해오라고 했을까? 플래그 아 그 페이지 참고할 페이지가 페이지 82쪽 아 넓게 안있어 아 헷갈려 헷갈려 헷갈려 히어로 치쿠 히어로 치쿠
 그럼 초대해서 주면 안 돼? 너무.. 이거 나보다 비싸 질툭할 거 같은데 나보다 비싸네요 진짜로 나보다 비싸네요 술을 여태까지 넣는 게 웃기네 나 이거 나중에 친해져 내? 막 걸어 진지하냐는 얘기야? 한 번만 친해져 봐야 돼? 진짜 무례하다 내가 이럴 때마다 친구들한테 한 얘기 숨쉬듯이 무례하다는 표현을 쓰고 숨쉬듯이 무례하다는.. 쉽지 않네 그래서 CSM 몇 쪽까지 하고 아니 82쪽이 82쪽의 비보형 값들을 사용하는 이유 값들을 사용하는 이유를 하고 플래그 하고 다음 주 화요일이니까 다음 주 화요일이니까 나 29일까지 29일 그렇지?
 4.1이랑 4.2 4.1, 4.2 어, 너 못 되겠다 가슴채고 오늘 끄게 고생하셨습니다 어?
